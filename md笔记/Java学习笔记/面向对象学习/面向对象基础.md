

# 一，面向对象知识补充

## 1，构造器

**Java中一种特殊的方法，有以下几点**

- 通常包含在类中，通过提供构造器，来确保每个对象都被初始化
- 与类同名，没有数值类型和返回值
- 构造方法可以有0-n个，如下例

```java
class Apple{
    int sum;
    String color;
    
    //如下为构造器，也可以没有
    public Apple(){}
    public Apple(int sum){this.sum = sum;}
    public Apple(String color){this.color = color;}
    public Apple(int sum, String color){this.sum = sum;
        this.color = color;}
}


```



定义了一个类之后，就可以使用构造方法创建对象了

```java
class CreateApple{
    psvm{
        Apple a1 = new Apple();				//如不自定义构造器，用这样的方式创建对象
        Apple a2 = new Apple(6);
        Apple a3 = new Apple("red");
        Apple a4 = new Apple(12,"yellow");	//传不同的参数，调用相应的构造方法创建对象，给
    }										//对象成员赋予不同的初值	
}
```

**注意：如果你手动定义了一个非默认构造方法，则不能再使用系统提供的无参默认构造，因为系统不再提供**

例：

``` java 
class Apple1{
    int sum;
    String color;

    public Apple1(int sum){
        this.sum = sum;
    }
}

 Apple1 a5 = new Apple1(); //这样写会报错，因为在写Apple1类时自己定义了一个构造方法，则不能调用JVM给你的默认无参构造
        
```

## 2，方法的重写

方法的重写描述***子类与父类***之间的，例

```java
class Fruit{

    public void eat(){
        System.out.println("eat fruit");
    }
}

class Apple extends Fruit{						// 子类 extends 父类， 重写的方法在“返回值类型，方法名，参数列表”和父类保持一致
    @Override									// IDEA中会自动添加，为重写的方法的标识
    public void eat() {							// 子类重写的访问权限不能低于父类
        System.out.println("eat apple");
    }
}
public class ReWrite {
    public static void main(String[] args) {
        Apple a1 = new Apple();
        a1.eat();
        Fruit f1 = new Fruit();
        f1.eat();
    }
```

- 子类 extends 父类， 重写的方法在“***返回值类型，方法名，参数列表***”和父类保持一致
- IDEA中会自动添加@Override，为重写的方法的标识
- 子类重写的访问权限不能低于父类

## 3，成员初始化

1. 基本数据类型初始化

| 类型    | 初始值   |
| ------- | -------- |
| boolean | false    |
| char    | /u0000   |
| byte    | (byte)0  |
| int     | 0        |
| long    | 0L       |
| float   | 0.0f     |
| double  | 0.0d     |
| short   | (short)0 |

2. 字符串等引用类型的初始值为  ***NULL***
3. 构造器初始化

#### 初始化顺序

- 静态属性：static开头定义的属性
- 静态方法块：static{}包起来的代码块
- 普通属性：非static定义的属性
- 普通方法块：{}中的代码块
- 构造方法（构造器）：类名相同的没有返回值方法

顺序为：***静态属性 > 静态方法块 > 普通属性 > 普通方法块 > 构造函数***

#### 数组初始化

##### 	1.动态初始化（指定长度）

```java
// 数据类型[] 数组名称 = new 数据类型[数组长度]；

int[] array = new int[10];

//可以拆分成两个步骤
```



##### 2.静态初始化（指定内容）

```java
// 数据类型[] 数组名称 = new 数据类型[]{1,2,3,4,5}

double[] array = new double[]{1,2,3,4,5};
//或
double[] array;
array =new double[] {1,2,3,4,5};
//静态初始化固定长度
//静态初始化标准格式可以拆成两个部分
```



##### 3.静态初始化省略格式

```java
//数据类型[] 数组名称 = {1,2,3,4,5}

int []a = {1,2,3,4,5};

// 省略格式不能拆分成两个步骤
```

##### 4.数组的一些方法

```java
int arr[] = new int arr[10];

//获取数组长度    length方法
sout(arr.length);	// 10

//遍历输出字符串(数组) Arrays.toString()方法
sout(Arrays.toString(arr)) //[0,0,0,0,0,0,0,0,0,0,0], 因为没赋值
```

##### 5.对象数组

- 类比普通数组，对象数组用来存放对象而已

```java
/*
定义一个数组用来存储3个Person对象
 */
public class Demo01Array {
    public static void main(String[] args) {
        Person[] array = new Person[3];		//对象数组并没有为Person类对象申请空间，如下面的one two three对象仍然要自己new一个空间（初始化），对象数组只是一个装有不同对象的地址的数组罢了

        Person one = new Person("林蕊",20);
        Person two = new Person("刘思远",25);
        Person three = new Person("lr",22);		

        array[0] = one;
        array[1] = two;
        array[2] = three;

        Person per = array[2];
        System.out.println(per.getName()+per.getAge());

        
    }
}
```



##### 6.Static关键字

- 如果一个成员变量是静态成员变量

- 或者如果一个成员方法是静态成员方法，name

  ***那么可以通过它的类名直接调用***     	例如：

  ```java
  public class Test01 {
      static int a = 1008;
  
      static void printLin(){
          System.out.println("lr is a pig");
      }
  }
  
  public class Test {
      public static void main(String[] args) {
          Test01.printLin();
          System.out.println(Test01.a);
      }
  }					//直接通过类名称调用静态成员该方法和成员变量，并且推荐使用类名称直接调用静态成员或方法
  					//对于本类当中的静态方法可以省略名称
  ```

  注：***1，一个static字段对一个类所创造出的所有对象来说都只有一个储存空间，所以多个对象共享同一份数据，非static字段对于每个对象都会创建一份它独有的空间***

  ***2，静态不能直接访问非静态，比如说静态方法不能直接调用成员变量或成员方法***

  ***3，静态方法内不能使用this关键字***

  ***4，静态成员，静态方法都在方法区的静态区***

- ***static的用法***

```java
public class Student {
    private int id; //学号
    private static int idCounter = 0;//学号计数器，每当new一个新对象，计数器++
    private String name;
    private int age;

    public Student( String name, int age) {	//学号计数器，每当new一个新对象，计数器++
        this.id = ++idCounter;
        this.name = name;
        this.age = age;
    }

    public Student() {				//学号计数器，每当new一个新对象，计数器++
        this.id = ++idCounter;
    }

    public int getId() {
        return id;
    }

 //省略部分Getter/Setter方法
 
}


public class demo01StaticFeild {

    public static void main(String[] args) {
        Student stu1 = new Student("linrui",30);
        Student stu2 = new Student("lsy",99);
        Student stu3 = new Student("lll",23);

        System.out.println(stu1.getId());   //1
        System.out.println(stu2.getId());   //2
        System.out.println(stu3.getId());   //3

    }
}
```

- **静态代码块**

```java
public class 类名称{
    static{
        //静态代码块的内容
    }
}

//特点：当第一次用到本类时，静态代码块执行唯一一次
//静态内容优先于非静态内容优先于构造器，所以静态代码块比构造器先执行
```

**静态代码块的典型用途：**

**用来一次性地对静态成员变量进行赋值**

#### Java内存划分

 1. **栈内存(stack): 存放方法中的局部变量。**

    **局部变量：方法的参数，或者方法体。	作用域：一旦超出作用域，立即从栈内存消失**

2. **堆内存：凡是new出来的东西，都在堆内存。**

   **堆内存里的东西都有一个地址值**

3. **方法区(Method Area): 存储.class相关信息，包含方法的信息**
4. 本地方法栈：与操作系统相关
5. 寄存器：与CPU相关



## 4，API文档

​		***API使用步骤***

1. 打开帮助文档
2. 点击显示找到索引，看到输入框
3. 输入要找的API，回车
4. java.lang下的类不需要导包，其他需要
5. 看类的解释和说明
6. 学习构造方法
7. 使用成员方法



### scanner类

​	该类型为引用类型（不是基本类型就是引用类型）	

​	引用类型的一般使用步骤：

- ***导包***

  import  包路径.类名称

- ***创建***

  类名称 对象名 = new 类名称();

- ***使用***

  对象名.成员方法名

```java
import java.util.Scanner;

public class BasicNote01Scanner {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);  //system.in代表从键盘输入

        int a = sc.nextInt();
        String str = sc.next();

        System.out.println(a + str);
    }

}
```



### Random类

```java
/*
Random类生成随机数字

1，导包
2，创建对象
3，使用对象调用方法

 */
public class Demo01Random {
    public static void main(String[] args) {
        Random ran = new Random();
        int num1 = ran.nextInt(); //小括号留空，再int范围内生成随机数
        int num2 = ran.nextInt(10); //范围：左闭右开，[0-10)范围内生成随机数
        int num3 = ran.nextInt(10-3-1) + 3; //范围：[3-10)范围内生成随机数
        System.out.println(num1);
        System.out.println(num2);
    }
}
```

- 若要生成范围为m到n，则

```java
int num3 = ran.nextInt(n-m) + m;
```





***



# 二，面向对象-封装

## 1，Getter，Setter方法，private关键字



具体体现：

```java
public class Student {
    private int age;
    private String name;

    public void setAge(int age) {				
        if(age > 0)
        this.age = age;
        else
            System.out.println("Wrong age, set again");
    }

    public int getAge() {
        return age;
    }

    public void setName(String name){
        this.name = name;
    }

    public String getName(){
        return name;
    }
}

//getter setter方法的使用可以体现代码的封装性，在main方法中调用类中成员方法来设置私有的成员属性
```



- 注 : 使用该方法设置，对于基本类型中的boolean值，getter方法一定要写成isXxxde形式，例如：

  ```java
  public boolean isPig(){
      return judge;
  }		//判断是否是猪
  ```

  

## 2，this关键字

​	***通过谁调用方法，谁就是this。***例子如下：

```java
 public void setName(String name){
        this.name = name;
    }


public class CreateStudent {
    public static void main(String[] args) {
        Student stu01 = new Student();
       
        stu01.setName("lsy");				//此处this指针在setName方法里，根据通过谁调用方法，谁就是this，知道
        									//stu01对象调用setName方法，那么this就代表stu01;
    }
}
```

## 3，一个标准的类

- 所有成员变量都要使用private关键字修饰
- 为每一个成员变量编写一对Getter/Setter方法
- 编写一个无参数构造器
- 编写一个全参数构造器
- 这样的标准的类也叫做Java Bean

```java
public class Student {
    private String name;
    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public Student() {
    }
}																				
```

- 注：***上述代码在写完成员变量后可以自动生成，快捷键Alt+Insert;***

  

### 匿名对象

	  匿名对象就是只有右边的对象，没有左边的名字和赋值运算符

  例：

  ```java
  public class Person {
      String name;
  
      public String getName() {
          return name;
      }
  
      public void setName(String name) {
          this.name = name;
      }
  
      public Person() {
      }
  
      public Person(String name) {
          this.name = name;
      }
  }
  
  public class Demo02Anomymous {
      public static void main(String[] args) {
          Person one = new Person("高圆圆");
  
          new Person().name = "刘思远";
  
      }							/*
  匿名对象
  new 类名称();
  
  注意事项：匿名对象只能使用唯一一次，如果再用不得不再创建
  使用建议：如果确定一个对象只需要使用唯一一次，就可以创建匿名对象
   */
  }
  ```

  使用建议实例如下

  ```java
  /*
  使用匿名对象进行传参
   */
  public class Demo02Anonymous {
      public static void main(String[] args) {
  //        普通使用方式
          Scanner sc = new Scanner(System.in);
          int num = sc.nextInt();
  
  //          匿名使用方式，即不创建sc这个对象使用
          int num2 = new Scanner(System.in).nextInt();
  
  //          匿名对象进行传参
          methodParam(new Scanner(System.in));
      }
  
      public static void methodParam(Scanner sc){
          System.out.println(sc.nextInt());
  
      }
  }

  ```



## 4，字符串

### 	字符串的创建

注意：程序中的所有双引号包起来的字符串，**都是String类的对象**

字符串的特点：
1,**字符串的内容永不可变【重点】**
2,正是因为字符串的内容不可改变，所以字符串是可以共享使用的。
3,字符串效果上相当于char[]型字符数组，但是底层原理是byte[]字节数组。

创建字符串的常见3+1种方式。

```
三种构造方法：
public String() ://创建一个空白字符串，不含有任何内容
public String(char[] array) ://根据字符数组的内容，来创建对应字符串
public String(byte[] array) ://根据字节数组的内容，来创建对应字符串
```

```
1种直接创建 String str = "Hello";
```

```java
public class demo01String {
    public static void main(String[] args) {
        //使用空参构造
        String str1 = new String(); //小括号留空，说明什么内容都没有
        System.out.println("第一个字符串：" + str1);

        //根据字符数组创建字符串
        char[] charArray = {'A','B','C'};
        String str2 = new String(charArray);
        System.out.println("第二个字符串" + str2);

        //根据字节数组来创建字符串
        byte[] byteArray = {97, 98, 99};
        String str3 = new String(byteArray);
        System.out.println("第三个字符串" + str3); //ctrl + 点击 可查看源码
    }
}
```

### 字符串的常量池

字符串常量池，程序当中**只有直接写上双引号的字符串，才在字符串常量池**，（在堆内存中）中 new的对象不在常量池当中

对于基本类型来说， ==是进行数值比较
**对于引用类型来说， ==是进行【地址值】进行比较**

```java
public class Demo02StringPool {

    public static void main(String[] args) {
        String str1 = "abc";
        String str2 = "abc";

        char[] charS = {'a','b','c'};
        String str3 = new String(charS);

        System.out.println(str1 == str2);   //true
        System.out.println(str1 == str3);   //false
        System.out.println(str2 == str3);   //false
    }
}
```

### 字符串常用方法，最好记下来

#### equals()方法

 "=="是进行对象的地址值的比较，如果确实需要对字符串进行比较，可以使用两种方法

public boolean equals(Object obj): 参数可以是任何对象，只有参数是一个字符串且内容相同才会给一个true
备注：任何对象都能用Object进行接收

推荐："abc".equals(str1)

不推荐：str1.equals("abc")		//如果str1为null，可能会导致空指针异常

```java
public class demo01StringEquals {
    public static void main(String[] args) {
        String str1 = "Hello";
        String str2 = "Hello";

        char []arrayStr = {'H','e','l','l','o'};
        String str3 = new String(arrayStr);

        System.out.println(str1.equals(str2)); //true
        System.out.println(str2.equals(str3));  //true
        System.out.println(str1.equals(str3)); //true

        char[] arrayStrA = {'H','E','L','L','O'};
        String str4 = new String(arrayStrA);
        System.out.println(str1.equals(str4)); //false
    }
}
```

***equalsIgnoreCase()方法***

```java
String str5 = "Hello";
String str6 = "HELLO";
System.out.println(str5.equalsIgnoreCase(str6)); //true 忽略大小写
```

#### 与获取有关的方法

```java
public int length(): 获取字符串长度
public String concat(String str):将当前字符串和指定字符串拼接并返回新的字符串
public char charAt(int index): 获取指定索引位置的单个字符
public int indexOf(String str): 查找参数字符串在本字符串中首次出现的索引位置，如果没有，返回-1值
```

```java
public class demo04StringGet {
    public static void main(String[] args) {
        //获取字符串长度
        int length = "ndfsknfkslflslsnf".length();
        System.out.println(length);  //17

        //拼接字符串
        String str1 = "Hello";
        String str2 = "World";
        String str3 = str1.concat(str2);
        System.out.println(str1);   //Hello
        System.out.println(str2);   //World
        System.out.println(str3);   //HelloWorld

        //获取指定索引位置的单个字符
        String str4 = "Hello Java";
        System.out.println(str4.charAt(3)); //l 第3+1个位置的字符

        //查找小字符串在大字符串中第一次出现的位置
        //如果根本没有，返回-1值
        String str5 = "lin rui is a really cute cute pig";
        System.out.println(str5.indexOf("cute"));  //20, 即第一个cute首字母的位置
        System.out.println(str5.indexOf("lsy"));    //-1，因为没找到，返回-1


    }
}
```

#### 字符串截取方法

```Java
/*
字符串截取方法：

public String substring(int index):截取从索引位置一直到字符串末尾，返回新字符串
public String substring(int begin, int end): 截取[begin,end)区间内字符串，并返回
 */
public class demo05SubString {

    public static void main(String[] args) {
        String str1 = "abcdefghijklmnopqrstuvwxyz";
        String str2 = str1.substring(8);
        String str3 = str1.substring(23,26);

        System.out.println(str2);   //i之后的所有
        System.out.println(str3);   //xyz
    }
}
```

#### 与转换有关的方法

```java
/*
String当中与转换相关的方法有：

public char[] toCharArray(): 将当前字符串拆分成为字符数组做为返回值
public byte[] getBytes(): 获得当前字符串底层的字节数据
public String replace(CharSequence oldString, CharSequence newString):
将所有出现的老字符串替换成新的字符串，返回替换之后的结果新字符串
CharSequence意思是可以接受字符串
public static String valueOf(int i) : 把int i从整型转化成为字符串类型
 */
public class demo05StringConvert {
    public static void main(String[] args) {
        //转换成为字符数组
        char[] chars = "lin is a pig".toCharArray();

        //获得当前字符串底层的字符数据
        byte[] bytes = "Hello".getBytes();
        for (int i = 0; i < bytes.length; i++) {
            System.out.println(bytes[i]); //Hello的ASCII码
        }
        //替换字符
        String str = "hfjskhfsksakjldaldjal";
        String strNew = str.replace("l","*");
        System.out.println(strNew); //  hfjskhfsksakj*da*dja*
        
        //转化为字符串类型
        int a = 10;
        String strNum = String.valueOf(a) //输出字符串"10";
    }
}
```

#### 字符串的分割方法

```java
/*
字符串的分割方法：
public String[] split(String regex):按照参数的规则，将字符串切成若干份。
regex:正则表达式的简写

注意事项：
split方法的参数实际上是一个正则表达式，如果按照英文"."进行切分，必须写成"\\."
 */

public class demo07StringSplit {

    public static void main(String[] args) {
        String str1 = "aaa,bbb,ccc";
        String[] array1 = str1.split(","); //以逗号为分隔，切成三段
        for (int i = 0; i < array1.length; i++) {
            System.out.println(array1[i]); // aaa   bbb   ccc
        }

        String str2 = "XXX.YYY.ZZZ";
        String []array2 = str2.split("\\.");
        for (int i = 0; i < array2.length; i++) {
            System.out.println(array2[i]);      //果按照英文"."进行切分，必须写成"\\."
        }
    }
}
```

## 5，Arrays类



```
/*
java.util.Arrays是一个与数组有关的工具类，里面提供了大量的静态方法，用来实现数组常见操作

public static String toString(数组)：将参数数组按照默认格式变成字符串
public static void sort(数组)：按照默认升序对数组进行排序
 */
public class demo01Arrays {

    public static void main(String[] args) {
        int[] intArray = {10,20,30};
        String intStr = Arrays.toString(intArray); //将参数数组按照默认格式变成字符串

        System.out.println(intStr);     //[10, 20, 30]

        char[] charArray = {'c','d','b','D','B','A'};
        Arrays.sort(charArray);
        System.out.println(Arrays.toString(charArray)); //[A, B, D, b, c, d]
    }
}
```

## 6，Math类

```java

public static double abs(double num) //获取绝对值
public static double ceil(double num)// 向上取整
public static double floor(double num)//向下取整
public static long round(double num)//四舍五入

```





#   四，泛型

## 1，ArrayList集合

- ***ArrayList也是一个类***

```java
/*
数组的长度不可以改变。
ArrayList集合的长度可以改变。

对于ArrayList来说，<E>代表泛型
泛型：也就是装在集合中的当前所有元素，全都是同统一的什么类型
注意：泛型只能是引用类型，不能是基本类型

注意事项：对于ArrayList来说，直接打印得到的不是地址，而是内容，
如果内容为空，得到的是空的中括号[];
 */
public class demo01ArrayList {
    public static void main(String[] args) {
        //创建了一个ArrayList集合，名字叫arrList，里面全是String字符串类型数据
        //从jdk1.7开始,右边的尖括号内部可以不写内容
        ArrayList<String> arrList = new ArrayList<>();
        System.out.println(arrList);    //[]

        arrList.add("林小蕊");
        System.out.println(arrList); //[林小蕊]

        arrList.add("刘小远");
        System.out.println(arrList);//[林小蕊, 刘小远]
    }
}
```

- ArrayList常用方法

```java
/*
ArrayList常用方法:

public boolea add(E e):向集合当中添加元素，参数类型和泛型一致，返回值是是否添加成功
对于ArrayList来说，添加一定成功，但是对于其他集合，不一定成功；
public E get(int index):从集合当中获取元素，index是索引编号，和数组一样从0开始；返回值是对应位置的元素
public E remove(int index):从集合中删除元素，index是索引编号，返回值是对应位置元素
public int size():获取集合长度并返回该长度
 */
public class demo02ArrayListMethod {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();

        list.add("林小蕊");
        list.add("刘小远");
        list.add("林大蕊");
        list.add("刘大远");
        System.out.println(list); //[林小蕊, 刘小远, 林大蕊, 刘大远]

        String name = list.get(2);
        System.out.println(name);

        System.out.println(list.size()); // 4

        String whoRemoved = list.remove(2);
        System.out.println(whoRemoved);

        System.out.println(list.size()); //3

        System.out.println(list); //[林小蕊, 刘小远, 刘大远]

    }
}
```

- 遍历

```java
for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }		输出list对象内已经添加的所有集合
```

- 如果希望向集合ArrayList当中存储基本类型的数据，必须使用基本类型的***包装类，位于java.lang包下***

- 从jdk1.5开始，支持自动装箱，自动拆箱
  **自动装箱 基本类型->引用类型**
  **自动拆箱 引用类型->基本类型**

| 基本类型 | 包装类（引用类型） |
| -------- | ------------------ |
| byte     | Byte               |
| short    | Short              |
| int      | Integer            |
| long     | Long               |
| float    | Float              |
| double   | Double             |
| char     | Character          |
| boolean  | Boolean            |

```java
public class demo04ArrayListBasic {

    public static void main(String[] args) {
        ArrayList<String> listA = new ArrayList<>();

        ArrayList<Integer> listInt = new ArrayList<>();
    }//使用方法和之前的String类型相同，不过多赘述
```

# 三，面向对象-继承

## 1，继承的基本语法



- **继承是多态的前提，没有继承就没有多态**

  继承解决的主要问题就是：共性抽取。

  继承关系当中的特点：

  1. 子类可以拥有父类的“内容”
  2. 子类还可以有自己专有的内容

  ```java
  /*
  在继承的关系中：“子类就是一个父类”
  例如父类是员工，子类是讲师，那么“讲师就是一个员工”。关系：is-a
  
  定义父类格式：（一个普通的类） */
  public class 父类名称{
          //...
  }
  
  // 定义子类格式：
  public class 子类名称 extends 父类名称{
          //...
  }
  
  
  ```

  下面是一个继承的例子：

  ```java
  //定义一个父类：员工
  public class Employee {
  
      public void method(){
          System.out.println("方法执行");
      }
  }
  //定义一个子类：教师
  public class Teacher extends Employee{
  
  }
  
  public class demo01Extends {
  
      public static void main(String[] args) {
          //创建一个子类对象
          Teacher teacher = new Teacher();
          //Teacher类虽然啥也没写，但是会继承来自父类的方法
          teacher.method();
  
      }
  }
  ```

## 2，继承中成员变量的访问特点

```java
/*
在父类对象的继承关系中，如果成员变量重名，则创建子类对象时，访问有两种方式：

直接通过子类对象访问成员变量：
    等号左边是谁，就优先用谁，没有则向上找
间接通过成员方法访问成员变量：
    方法属于谁，就优先用谁，没有，则向上找
 */
```

```java
public class Fu {

    int numFu = 10;
    int num = 100;

    public void methodFu(){
        //使用的是本类当中的
        System.out.println(num);
    }
}

public class Zi extends Fu{

    int numZi = 20;
    int num = 200;

    public void methodZi(){
        //本类中有num,优先用本类
        System.out.println(num);
    }
}

public class demo01ExtendsField {

    public static void main(String[] args) {
        Fu fu = new Fu();

        Zi zi = new Zi();

        //等号左边是谁优先用谁
        System.out.println(zi.num); //优先子类：200
        System.out.println(zi.numFu);   //没有则向上找,父类有，则是10

        //这个方法是子类的，优先用子类的
        zi.methodZi(); //200
        //这个方法是父类的，优先用父类的
        zi.methodFu(); //100
    }
}
```

## 3，区分子类方法中重名的三种变量

```java
局部变量：   直接写
本类中的成员变量名： this.num
父类中的成员变量名：  super.num
```

例：

```java
public class Fu {

    int num = 10;
}
public class Zi extends Fu{

    int num = 20;

    public void method(){
        int num = 30;
        System.out.println(num);    //30,局部变量
        System.out.println(this.num);   //20,本类中的成员变量
        System.out.println(super.num);  //10,父类的成员变量
    }
}
```

## 4，继承中成员方法的访问特点及方法的重写

```java

    父类子类中方法重名的访问规则：
        创建的对象是谁，就优先用谁，如果没有就向上找

重写(Override)
概念：在继承当中，方法名称一样，参数列表也一样。覆盖，复写。

注意事项：
1.必须保证父子类之间的方法的名称相同，参数列表也相同。
@Override：写在方法前面，用来检测是不是有效的正确覆盖重写。
2.子类方法的返回值必须小于等于父类方法的返回值范围
Object类是所有类的公共最高父类
3.子类方法的权限必须大于等于父类方法的权限修饰符   //要么一样，子类比父类的范围更大
备注：public > protected > (default) > private
(default)代表什么都不写
 
```

例：

```java
public class Fu {
   
    public void method(){
        System.out.println("父类方法重名的执行");
    }
}
public class Zi extends Fu{

    @Override
    public void method(){
        System.out.println("父类方法重名的执行");
    }
}
```

## 5，继承中构造方法的访问特点

```java
继承关系中父子类构造方法的访问特点：

1.子类构造方法中有一个默认隐含大的"super()"调用，所以一定是先调用的父类构造，后执行子类构造。
2.可以通过super关键字来子类构造调用父类重载构造
3.父类构造的调用，必须是子类构造方法的第一个语句
```

例

```java
public class Fu {
    public Fu(){
        System.out.println("父类无参构造");
    }
    public Fu(int num){

        System.out.println("父类有参构造方法");
    }
}
public class Zi extends Fu {

    public Zi(){
    //    super();    //调用父类构造方法，隐藏起来的
        super(10);		//必须是子类构造方法的第一个语句
        System.out.println("子类构造方法");
    }
}
public class demo01Constructor {
    public static void main(String[] args) {
        Zi zi = new Zi();	//父类有参构造方法	子类构造方法
						//子类构造方法。先调用的父类构造，后执行子类构造。

    }
}
```



## 6，super, this关键字的三种用法

### 	super关键字

```java
/*
super关键字的三种用法：
1. 在子类的成员方法中，访问父类的成员变量
2，在子类的成员方法中，调用父类的成员方法
3，在子类的构造方法中，调用父类的构造方法
 */
public class Fu {
    int num = 10;

    public void method(){
        System.out.println("父类方法执行");
    }
}
public class Zi extends Fu {
    int num = 20;
    public Zi(){
        super();    //调用父类的构造方法
    }
    public void methodZi(){
        System.out.println(super.num);  //10    访问父类中的成员变量
    }

    @Override
    public void method(){
        super.method();         //父类方法执行    调用父类中的成员方法
        System.out.println("子类方法执行");
    }

}

```

### 	this关键字

```java
/*
1.在本类中的成员方法中，访问本类中的成员变量。
2.在本类的成员方法中，访问本类的另一个成员方法。
3.在本类的构造方法中，访问本类中的另一个构造方法
在第三种用法中要注意：
this()
调用也必须是构造方法的第一个语句，并且是唯一一个
super和this两种构造调用不能同时使用
 */
public class Zi extends Fu{
    int num;
    public Zi() {
        this(10);   //在本类的构造方法中，访问本类中的另一个构造方法
    }

    public Zi(int num) {
        this.num = num;			//在本类中的成员方法中，访问本类中的成员变量。
    }

    public void methodA(){
        System.out.println("AAA");
    }
    
    public void methodBBB(){
        this.methodA();         // AAA 在本类的成员方法中，访问本类的另一个成员方法。
    }
    
}
```

### Java语言继承的三个特点

1. Java语言是单继承的 ：一个类的直接父类只有唯一一个
2. Java语言可以多级继承： 一个类的父类也可以有父类
3. 一个父类可以拥有很多个子类



## 7，抽象

如果父类当中的方法不确定如何进行{}方法体实现，那么这就是一个***抽象方法***

```java
抽象方法：就是加上abstract关键字，然后把大括号去掉，直接分号结束
抽象类：抽象方法所在的类必须是抽象类，在class之前写上abstract即可

如何使用抽象类和抽象方法：
1，不能直接创建new抽象类对象
2，必须使用一个子类来继承父类。
3，这个子类必须覆盖重写抽象父类当中的所有抽象方法：即去掉抽象方法中的abstract关键字，然后补上方法体	（除非子类也是一个抽象类，如果子类也是一个抽象类，那么父类的抽象方法体没在子类中实现就可在子类的子类中实现）
4，一个抽象类不一定含有抽象方法，但是一个抽象方法的所在类一定是抽象类

```

例

```java

public abstract class Animal {

        //这是一个抽象方法，代表吃东西，但是具体吃什么（大括号中的内容）不确定
        public abstract void eat();

        //这是一个普通成员方法
//        public void method(){
//
//        }
//

}
public class Cat extends Animal {		//这是一个抽象类的子类，该子类不是抽象类，所以要重写父类的所有抽象方法

    @Override
    public void eat(){
        System.out.println("猫猫吃鱼");
    };
}
public class demoMain {

    public static void main(String[] args) {
        Cat cat = new Cat();
        cat.eat();
    }
}
```

# 四，面向对象-多态

## 1，接口

### 接口的定义

```java
/*
接口就是多个类的公共规范。
接口是一种引用数据类型，最重要的内容就是其中的，抽样方法。

如何定义一个接口的格式：
public interface 接口名称{                  //大驼峰式命名规则
    //接口内容

备注：换成了interface关键字之后，编译生成的字节码文件仍然是 .java --> .class。
}

如果是java7, 那么接口中可以包含的内容有
1，常量
2，抽象方法

如果是java8,还可以额外包含有
3，默认方法
4，静态方法

如果是java9,还可以额外包含有
5，私有方法
 */
 
/*
在任何版本的Java中，接口都能定义抽象方法：
格式：
public abstract 返回值类型 方法名称（参数列表）;

注意事项：
1，接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract
2，这两个关键字修饰符，可以选择性的省略。（初学不推荐）
 */

public interface MyInterfaceAbstract {

    public abstract void methodAbs();   //写上关键字

    void methodAbs1();                  //不写关键字
}
```

### 接口的使用

```java
接口使用步骤：
1，接口不能直接使用，必须有一个实现类来实现次此接口
格式：
public class 实现类名称 implements 接口名称{
    //...
    }
2，接口的实现类必须覆盖重写接口中的所有抽象方法
实现：去掉abstract关键字，加上方法体{}。
3，创建实现类的对象，进行使用。
    
注意事项：
如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己必须是抽象类，那么他的子类必须实现重写这个实现类，这个实现类就不能直接用了
```

例

```java
public interface MyInterfaceAbstract {

    public abstract void methodAbs();   //写上关键字

    void methodAbs1();                  //不写关键字
}

public class MyInterfaceAbstractImpl implements MyInterfaceAbstract{	//	接口的实现类必须覆盖重写（实现）接口中的所有抽象方法


    @Override
    public void methodAbs() {		//实现：去掉abstract关键字，加上方法体{}
        System.out.println("这是第一个方法");
    }

    @Override
    public void methodAbs1() {
        System.out.println("这是第二个方法");
    }
}

public class demo01Interface {
    public static void main(String[] args) {
        MyInterfaceAbstractImpl impl = new MyInterfaceAbstractImpl();			//3，创建实现类的对象，进行使用。注意：不能创建接口的对象，是错误写法
									//
        impl.methodAbs();
        impl.methodAbs1();
    }
}
```



### 接口的默认方法的使用

```java
/*
从java 8开始，接口例允许定义默认方法
格式：
public default 返回值类型 方法名称（参数列表）{
    //方法体
}

备注：接口当中的默认方法可以解决接口升级问题。
 */


public interface MyInterfaceDefault {

    //抽象方法
    public abstract void methodAbs();
    
    public default void methodDefault(){		//接口当中的默认方法可以解决接口升级问题，在两个实现类中都没有重写	该方法，并没有报错，因为调用默认方法，如果实现类当中即使没有，会向上找接口。但是你也可以选择在实现类中重写该方法
        System.out.println("这是新添加的默认方法");
    }
}

public class MyInterfaceDefaultA implements MyInterfaceDefault{
    @Override
    public void methodAbs() {
        System.out.println("实现了抽象方法，AAA");
    }
}

public class MyInterfaceDefaultB implements MyInterfaceDefault{
    @Override
    public void methodAbs() {
        System.out.println("实现了抽象方法，BBB");
    }

    @Override
    public void methodDefault() {
        System.out.println("实现了覆盖重写B类的默认方法");
    }
}

/*
1.接口的默认方法，可以通过接口实现类对象直接调用
2.接口的默认方法，也可以被接口实现类进行覆盖重写
 */
public class demo02Interface {

    public static void main(String[] args) {
        MyInterfaceDefaultA a = new MyInterfaceDefaultA();
        a.methodAbs();  //调用抽象方法，实际运行的是右侧实现类

        //调用默认方法，如果实现类当中没有，会向上找接口
        a.methodDefault();
        System.out.println("========================================");
        MyInterfaceDefaultB b = new MyInterfaceDefaultB();
        b.methodDefault();
    }
}
```

### 接口的静态方法的使用

```java
/*
从java 8开始，接口中允许定义静态方法
格式
public static 返回值类型 方法名称(参数列表){
    //方法体
}
 */
public interface MyInterfaceStatic {

    public static void methodStatic(){
        System.out.println("这是接口的静态方法");
    }
}

public class MyInterfaceStaticImpl implements MyInterfaceStatic{
    //接口中只有静态方法，没有抽象方法，并没有报错，没必要重写
}

/*
注意：不能通过接口实现类的对象来调用接口中的静态方法。                           抽象类和接口都不能直接new
正确使用方法：
接口名称.静态方法名(参数)；
 */
public class demo03Interface {

    public static void main(String[] args) {

        //直接通过接口名称调用静态方法
        MyInterfaceStatic.methodStatic();

    }
}
```

### 接口的私有方法定义

```java
/*
问题描述：
我们需要抽取一个共有方法，来解决两个默认方法之间重复代码的问题。
但是这个共有方法不应该让实现类使用，应该是私有化的

解决方案：
从java9开始，接口当中允许定义私有方法。
1.普通私有方法，解决多个默认方法之间重复代码问题
格式：
private 返回值类型 方法名称(参数列表){
    //方法体
}
2.静态私有方法，解决多个静态方法之间重复代码问题
格式：
private static 返回值类型 方法名称(参数列表){
 //方法体
 }
 */
public interface MyInterfacePrivateA {

    public default void methodDefault1(){
        System.out.println("默认方法1");
        methodCommon();
    }
    public default void methodDefault2(){
        System.out.println("默认方法2");
        methodCommon();

    }

    private void methodCommon(){	//普通私有方法，解决多个默认方法之间重复代码问题
        System.out.println("AAA");
        System.out.println("BBB");
        System.out.println("CCC");
    }
}

public interface MyInterfacePrivateB {

    public static void methodDefault1(){
        System.out.println("静态方法1");
        methodStaticCommon();
    }
    public static void methodDefault2(){
        System.out.println("静态方法2");
        methodStaticCommon();

    }

    private static void methodStaticCommon(){		//静态私有方法，解决多个静态方法之间重复代码问题
        System.out.println("AAA");
        System.out.println("BBB");
        System.out.println("CCC");
    }
}

public class demo01Interface {

    public static void main(String[] args) {
        MyInterfacePrivateB.methodDefault1();
        MyInterfacePrivateB.methodDefault2();	//静态方法调用直接：接口名.方法名

        MyInterfacePrivateAImpl a = new MyInterfacePrivateAImpl();
        a.methodDefault1();						//默认或普通方法的调用：接口的实现类先new一个对象，然后：对象名.方法名		注意：接口的实现类必须覆盖重写（实现）接口中的所有抽象方法，才能通过实现类使用抽象方法
        a.methodDefault2();
    }
}
```



### 接口的常量和使用

```java
*
接口当中也可以定义”成员变量“，但是必须使用public static final三个关键字进行修饰
从效果上看，这其实就是接口的【常量】。
格式:
public static final 数据类型 常量名称 = ”数据值“;
注意：
1，一旦使用final关键字进行修饰，说明不能改变。
2，接口当中的常量必须赋值，不能不赋值
3.接口中常量的名称，必须使用完全的大写字母，用下划线进行分隔。(推荐的命名规则)

 */

public interface MyInterfaceConst {
    //修饰词可以省略，但是省不省略都一样，初学者不建议省略
    public static final int NUM_OF_MY_CLASS  = 10;
}

public class demo01Interface {
    public static void main(String[] args) {
        // 访问接口当中的常量
        System.out.println(MyInterfaceConst.NUM_OF_MY_CLASS);//直接通过接口调用
    }
}
```



### 小结

- 在Java 9+版本中，接口的内容可以有：

1. 成员变量其实是常量，格式：

   [public] [static] [final] 数据类型 常量名称 = 数据值

   注意：常量必须进行赋值，且一旦赋值不能改变。常量名称完全用大写，且用下划线分隔。

   

2.  接口中最重要的就是抽象方法，格式：

    [public] [abstract] 返回类型 方法名称(参数列表);

    注意：实现类必须重写接口所有的抽象方法，除非实现类是抽象类。

    

3.  从Java 8开始，接口里允许定义默认方法，格式：

    [public] default 返回值类型 方法名称(参数列表){方法体}

    注意：默认方法也可以被实现类重写，如果没有重写，通过实现类对象间接调用接口里的默认方法 

    

4.  从Java 8开始，接口里允许定义静态方法，格式：

    [public]	static 返回值类型 方法名称（参数列表）{方法体}

    注意：应该通过接口名称直接调用，不能通过实现类对象调用接口静态方法

     

5. 从Java 9开始，接口里允许定义私有方法，格式：

   普通私有方法	private 返回值类型 方法名称(参数列表){方法体}

   静态私有方法 	private static返回值类型 方法名称(参数列表){方法体}

   注意：private方法只有通过接口自己才可以调用，不能被实现类或别人使用。

6. 类中静态方法静态变量不能被new出来的对象调用，要用直接通过类名(接口名).来调用。要用抽象类和接口不能直接new别人，要间接通过对应的父类和实现类来重写后间接new。



### 继承父类并实现多个接口及其注意事项

```java
/*
使用接口的时候，应该要注意：

1.接口是没有静态代码块和构造方法的 （未在下述代码中体现，但要知道）
2.一个类的直接父类时唯一的，但是一个类可以同时实现多个接口。

格式:
public class MyInterface implements MyInterfaceA,MyInterfaceB{
    //覆盖重写所有抽象方法
}
3. 如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可
4. 如果实现类没有覆盖重写所有接口中的所有抽象方法，那么实现类就必须是抽象类（未在下述代码中体现，但要知道）
5. 如果实现类所实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行重写
6. 一个类如果直接父类当中的方法和接口当中的默认方法产生了冲突，优先用父类中的方法 （未在下述代码中体现，但要知道）
 */

public interface MyInterfaceA {

    public abstract void methodA();

    public abstract void methodAbstract();

    public default void methodDefault(){
        System.out.println("默认方法AAA");
    }
}

public interface MyInterfaceB {

    public abstract void methodB();

    public abstract void methodAbstract();

    public default void methodDefault(){
        System.out.println("默认方法BBB");
    }
}

public class MyInterfaceImpl implements MyInterfaceA,MyInterfaceB{ //一个类可以同时实现多个接口

    @Override
    public void methodA() {
        System.out.println("覆盖重写了A方法");
    }

    @Override
    public void methodAbstract() {
        System.out.println("覆盖重写了共同方法");	//如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可
    }

    @Override
    public void methodDefault() {
        System.out.println("默认方法覆盖重写ABBA"); //如果实现类所实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行重写
    }

    @Override
    public void methodB() {
        System.out.println("覆盖重写了B方法");
    }
}

```

### 接口之间的多继承

```java
1.类与类之间是单继承的。直接父类只有一个
2.类与接口之间是多实现的。一个类可以实现多个接口。
3.接口与接口之间是多继承的

注意事项：
1. 多个父接口当中的抽象方法如果重复，没关系。
2. 多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，【而且带着default关键字】
```

```java
public interface MyInterfaceA {

    public abstract void methodA();

    public abstract void methodCommon();

    public default void methodDefault(){
        System.out.println("AAA");
    }
}

public interface MyInterfaceB {

    public abstract void methodB();

    public abstract void methodCommon();

    public default void methodDefault(){
        System.out.println("BBB");
    }
}

public interface MyInterface extends MyInterfaceA, MyInterfaceB{// 接口与接口之间是多继承的

    public abstract void method();

    @Override
    default void methodDefault() {	//多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，【而且带着default关键字】

    }
}

/*
上面这个子接口当中有几个方法？ 答：4个。
methodA 来源于接口A
methodB 来源于接口B
methodCommon 来源于A和B
method 来源于我自己
 */


public class MyInterfaceImpl implements MyInterface{	//类与接口之间是多实现的。一个类可以实现多个接口。
    @Override
    public void method() { }

    @Override
    public void methodA() { }

    @Override
    public void methodB() { }

    @Override
    public void methodCommon() { }
}
```

## 2，多态

- extends继承或者implements实现，是多态性的前提

### 多态的格式和使用

```java
/*
代码当中体现多态性，其实就是一句话：父类引用，指向子类对象
格式
父类对象 对象名 = new 子类名称();
或者：
接口名称 对象名 = new 实现类名称();
 */
public class Fu {
    public void method(){
        System.out.println("父类方法");
    }
    public void methodFu(){
        System.out.println("父类独有方法");
    }
}

public class Zi extends Fu{
    @Override
    public void method() {
        System.out.println("子类方法");
    }
}

public class demo01Multi {
    public static void main(String[] args) {
        //使用多态的写法
        //左侧父类的引用指向了右侧子类的对象
        Fu obj = new Zi();		//左父右子(左接口右实现)就是多态，比如哺乳动物类是生物类的子类，那么哺乳动物类new出来的小猫咪对象完全可以当成生物类来使用，该句话就可以理解为一个子类对象可以做为一个子类使用，也可以做为他的父类来使用
        
        obj.method();
        obj.methodFu();
    }
}


```

### 多态中成员变量和多态中成员方法的使用特点

```java
/*
访问成员变量的两种方式：

1.直接通过对象名称访问成员变量：等号左边是谁优先用谁，没有则向上找
2.通过成员方法访问成员变量: 看该方法属于谁，优先用谁，没有则向上找
 */
public class Fu {
    int num = 10;

    public void showNumber(){
        System.out.println(num);
    }
}
public class Zi extends Fu{
    int num = 20;

    int age = 16;

    @Override
    public void showNumber() {
        System.out.println(num);
    }
}
public class demo01MutiField {

    public static void main(String[] args) {
        //使用多态的写法，父类引用指向子类对象
        Fu obj = new Zi();
        System.out.println(obj.num);    //10,等号左边是谁优先用谁，没有则向上找
   //     System.out.println(obj.age);    //错误写法，不会向下查找

        obj.showNumber();   //子类没有覆盖重写，就是父，10
                            //子类如果覆盖重写，就是子，20
    }
}			//多态本质：obj只能用父类和往上的东西，要想向下，只能通过子类重写父类成员方法来实现，这个时候obj就会优先调用重写的成员方法
```

### 使用多态的好

- 好处：无论右边new的时候换成哪个子类对象，等号左边调用的方法都不会变化

  <img src="C:\Users\mi\Desktop\repositorys\repo1\md笔记\md入门\image\java01.png" alt="java01" style="zoom:150%;" />

### 对象的向上转型和对象的向下转型<img src="C:\Users\mi\Desktop\repositorys\repo1\md笔记\md入门\image\java02.png" alt="java02" style="zoom: 200%;" />



### ![java03](C:\Users\mi\Desktop\repositorys\repo1\md笔记\md入门\image\java03.png)

```java
/*
向上转型一定是安全的，没有问题的，正确的。但是也有一个弊端：
对象一旦向上转型为父类，那么就无法使用子类中原本特有的内容

解决方案：用对象的向下转型【还原】
 */

public abstract class Animal {

    public abstract void eat();
}
public class Cat extends Animal {
    @Override
    public void eat() {
        System.out.println("猫吃鱼");
    }

    public void catchMouse(){
        System.out.println("抓老鼠");
    }
}
public class Dog extends Animal{
    @Override
    public void eat() {
        System.out.println("狗吃SHIT");
    }

    public void watchHouse(){
        System.out.println("狗看家");
    }
}


public class   demo01Main {

    public static void main(String[] args) {
        // 对象的向上转型就是父类引用指向子类对象
        Animal animal = new Cat();  //本来创建的时候是猫
        animal.eat();

    //    animal.catchMouse;  //错误写法

        //向下转型，进行还原
        Cat cat = (Cat) animal; //类似于 int num = (int)10.0;

        //下面是错误的向下转型
        //本来new的是一只猫，现在非要当作狗
        Dog dog = (Dog) animal; //错误写法，编译不会报错，运行会出现异常：java.lang.ClassCastException		类似于 int num = (int)10.5; 不可以会发生精度损失
                                //而在类的转换中会发生 类转换异常
    }
}
```

### 用instanceof关键字进行类型判断

```java
/*
如何才能知道一个父类引用的 对象本来是什么子类
格式：
对象 instanceof 类型
这将会得到一个boolean信息，也就是判断前面的对象能不能当作后面的类型的实例
 */
//此例中的各类都沿用上例中的类
public class demo02Instanceof {

    public static void main(String[] args) {
        Animal animal = new Cat();
        animal.eat();   //猫吃鱼

        //判断一下animal本来是不是Dog
        if(animal instanceof Dog){
            Dog dog = (Dog) animal;
            dog.watchHouse();
        }
        //判断一下animal本来是不是Cat
        if (animal instanceof Cat){
            Cat cat = (Cat) animal;
            cat.catchMouse();
        }
    }
}
```

# 五，内部类

## 1，final关键字

### 		final关键字概念与四种用法

```java
/*
final关键字代表最终，不可改变的

常见四种用法：
1. 可以用来修饰一个类
2. 可以用来修饰一个方法
3. 还可以用来修饰一个局部变量
4. 还可以用来修饰一个成员变量
 */
public class demo01Final {
    public static void main(String[] args) {

        //一旦使用final来修饰局部变量，那么这个局部变量只能赋值一次
        final int num1 = 10;			//还可以用来修饰一个局部变量
   //     num1 = 10;  //  哪怕第二次赋值和第一次相同也不行

        //对于基本类型中，不可变说的是变量中的数据不可以改变
        //对于引用类型中，不可变说的是变量当中的地址不可改变
        Student stu1 = new Student("赵丽颖");
        System.out.println(stu1.getName()); //赵丽颖
        System.out.println(stu1);
        stu1 = new Student("霍建华");
        System.out.println(stu1.getName()); //霍建华
        System.out.println(stu1);

        System.out.println("========================");
        final Student stu2 = new Student("高圆圆");
        //错误写法，final的引用类型变量，其中地址不可以改变
        //  stu2 = new Student("赵又廷"）;
        System.out.println(stu2.getName()); //高圆圆
        stu2.setName("高圆圆圆圆圆");
        System.out.println(stu2.getName()); //高圆圆圆圆圆圆
    }
}

/*
对于成员变量来说，如果使用final关键字修饰，那么这个变量也照样是不可以改变的

1. 由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了
2. 对于final的成员变量，要么使用直接赋值，要么使用构造方法赋值。二者选其一
3. 必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值
 */
public class Person {

    private final String name ;

    public String getName() {		
        return name;
    }

//    public void setName(String name) {
//        this.name = name;				使用构造方法赋值
//    }

    public Person(String name) {		
        this.name = name;			
    }

    public Person() {
        name = "李四";			//使用构造方法赋值
    }
}

/*
当final关键字用来修饰一个类的时候，格式：
public final class 类名称{
    // ...
}

含义：当前这个类不能有任何子类。（太监类）
注意：一个类如果是final的，那么其中的所有成员方法都无法进行覆盖重写(因为没有儿子),所以它不能是一个抽象类
 */
public final class MyClass /*extends Object*/{

    public void method(){
        System.out.println("这是一个方法");
    }
}
```

## 2，四种权限修饰符

```java
/*
Java中有四种权限修饰符：
        public > protected > default > private
同一个类    YES       YES      YES       YES
同一个包    YES       YES      YES       NO  
不同包子类   YES       YES      NO       NO
不同包非子类 YES       NO       NO        NO

注意: default不是关键字，而实根本不写
 */
```